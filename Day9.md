# 代码随想录算法训练营13期 字符串part02 28. 实现 strStr() 、459.重复的子字符串



 
 **学习时长大于3h**
 
## 28. 找出字符串中第一个匹配项的下标 难度：中等


### 第一想法:

这个要是用python的话，感觉很简单，调两个函数就解决了，我没记错的话，可以先调用in 看字符串是否存在， 然后调用.index 方法应该就可以吧
java的话，最直观的想到的肯定是，遍历haystack 的 字符，然后逐一进行匹配，我是想到一个类似窗口的方法，我试一试。

~~~

class Solution {
    public int strStr(String haystack, String needle) {
        int left = 0;
        int right=0;
        int m=haystack.length();
        int n= needle.length();
        if(m<n)
            return -1;
        while(right<m){
            
            while(haystack.charAt(left)==needle.charAt(0) && right<m){
                System.out.println("left:"+left);
                System.out.println("right:"+right);

                
                
                if(haystack.charAt(right)!=needle.charAt(right-left)){
                    right=left;
                    break;
                }
                right++;
                if ((right-left)==n)
                    return left;
                
            }
            
            left++;
            right++;
        }
        return -1;
    }
}

~~~




### 题解:

提供两种解法，一种是我自己没看KMP 算法之前，写出来的，也能通过用例，虽然看起来时间比较复杂。
KMP的解法我不提供code了，因为我想留给自己二刷的时候来写code，但是整体原理和code实现我自认为都理解了，在这里分享给大家。




#KMP 
### 核心思想
KMP的经典思想就是:**当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。**


### 前缀表
ext数组就是一个前缀表（prefix table）。

**前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。**

请记住文本串和模式串的作用：

要在文本串：aabaabaafa 中查找是否出现过一个模式串：aabaaf。

**前缀表是如何记录的呢？**

前缀表的任务是当前位置匹配失败，找到之前已经匹配上的位置，再重新匹配，此也意味着在某个字符失配时，前缀表会告诉你下一步匹配中，模式串应该跳到哪个位置。

**前缀表：**

**记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀**


## 关键点——原理（自己的理解）和 图解求next 数组过程

### 原理（自己理解）
首先是我的分析对于为什么要去寻找前缀和后缀，以及为什么前缀和后缀最长相等的，就能够像前缀表记录的那样遍历而不出错。
我觉得求前缀和求后缀的过程，其实可以等同于从一个字符串的起始朝末尾走，和从末尾朝起始走，比如aabaa 这个字符串。但是要注意的是，字符之间的顺序还是得按照原来的顺序

前缀：走一下， a， 后缀： 走一下 a。可以，相等。

前缀：再走一下 aa  后缀 ： 再走一下 aa 可以，相等

前缀再走 一下 aab  后缀： baa ，不相等了，所以 前缀表aabaaf 中 索引第4位应该放2.

那么为什么这样走相等，就能在遍历时不用遍历前面呢？

举个例子，当你正常匹配到aabaaf 时，肯定前面的aabaa 是匹配成功了的，那说明文本串前面也是这几个数.那现在f不匹配了，如果按照暴力匹配法，就应该从头开始，至少模式串要从第一位开始匹配，

**这里就是前面求相等前缀后缀起作用的地方了：**

假如模拟重新从模式串a开始，这时候发现如果从主串往前走一位也是a，所以这个其实可以从模式串的第二位aa开始，但是又发现如果主串再往前走一位，刚好前面还是aa，这个过程其实就是求前缀表的过程，

所以其实KMP 算法的核心确实是通过前缀表这种形式记住了，**每个位置的前面一部分信息和这个字符串最开始的信息的匹配程度。**

比如如果是0的话，我就知道你现在主串前面的部分是不可能能够跟模式串的最前面匹配上的，那在主串上就无须回退，重新遍历，这才导致KMP算法能够达到On的时间复杂度


### code——求next 数组的 图解
构造next 数组的步骤有下面三步
1.初始化

2.处理前后缀不相同的情况

3.处理前后缀相同的情况

两个指针i，j。j指向前缀末尾位置，i指向后缀末尾位置

next[i] 表示 i（包括i）之前最长相等的前后缀长度（其实就是j）
首先上面这个code，先理解getNext这个方法，i指向后缀末尾，但其实后缀末尾就是你在遍历这个字符串时指向的最末尾的字符。
所以i其实可以理解为有两个作用。

那么再看j，j是需要回退的，为什么，因为j指向前缀末尾，而前缀末尾，不会是一直往后走的，而是，比如如果遇到前后缀不匹配的情况，前缀末尾就会往前退。

那么前缀末尾应该退到哪里呢。

这里其实可以研究一下我们手算前后缀表的规律，假设我们要求next[i]， 最大值不超过 next[i-1]，也就是要么s[j]==s[i]的时候呢，next[i]=next[i-1]+1，为什么是这个数呢，因为，实际上，对于i-1 指向后缀末尾时，我们研究的这个字符串， 和 i指向后缀末尾时我们研究的这个字符串，前面的数都是一样的，也就是说前缀都是一样的，后缀的区别就是最后加了个s[i],所以如果s[j]==s[i]，那么显然前后缀匹配的长度+1就可以了。

所以说回来，后退应该怎么后退呢，我自己理解的时候也很困惑了，查了一些资料，我自己画图，图解了一下，自认为还算有点清晰，分享给大家。

![图解KMP，求next数组](https://user-images.githubusercontent.com/131168940/235049643-0215684a-3da8-49d5-83a9-38a7700b21f2.png)

